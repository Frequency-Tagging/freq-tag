
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_mne_freqtag_tutorial.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_plot_mne_freqtag_tutorial.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_mne_freqtag_tutorial.py:


==========================================================
Frequency-tagging: Basic analysis of an SSVEP/vSSR dataset
==========================================================

In this tutorial we compute the frequency spectrum and quantify signal-to-noise
ratio (SNR) at a target frequency in EEG data recorded during fast periodic
visual stimulation (FPVS) at 12 Hz and 15 Hz in different trials.
Extracting SNR at stimulation frequency is a simple way to quantify frequency
tagged responses in MEEG (a.k.a. steady state visually evoked potentials,
SSVEP, or visual steady-state responses, vSSR in the visual domain,
or auditory steady-state responses, ASSR in the auditory domain).
For a general introduction to the method see
`Norcia et al. (2015) <https://doi.org/10.1167/15.6.4>`_ for the visual domain,
and `Picton et al. (2003) <https://doi.org/10.3109/14992020309101316>`_ for
the auditory domain.
**Data and outline:**
We use a simple example dataset with frequency tagged visual stimulation:
N=2 participants observed checkerboard patterns inverting with a constant
frequency of either 12.0 Hz of 15.0 Hz.
32 channels wet EEG was recorded.
We will visualize both the power-spectral density (PSD) and the SNR
spectrum of the epoched data,
extract SNR at stimulation frequency,
plot the topography of the response,
and statistically separate 12 Hz and 15 Hz responses in the different trials.
Since the evoked response is mainly generated in early visual areas of the
brain the statistical analysis will be carried out on an occipital
ROI.

.. contents:: Outline
   :depth: 2

.. GENERATED FROM PYTHON SOURCE LINES 34-46

.. code-block:: default

    # Authors: Dominik Welke <dominik.welke@web.de>
    #          Evgenii Kalenkovich <e.kalenkovich@gmail.com>
    #
    # License: BSD (3-clause)

    import matplotlib.pyplot as plt
    import mne
    import numpy as np
    from scipy.stats import ttest_rel

    from freqtag import psd_from_mne_epochs








.. GENERATED FROM PYTHON SOURCE LINES 47-59

Data preprocessing
------------------
Due to a generally high SNR in SSVEP/vSSR, typical preprocessing steps
are considered optional. This doesn't mean, that a proper cleaning would not
increase your signal quality!

* Raw data have FCz reference, so we will apply common-average rereferencing.

* We  will apply a 0.1 highpass filter.

* Lastly, we will cut the data in 20 s epochs corresponding to the trials.


.. GENERATED FROM PYTHON SOURCE LINES 59-91

.. code-block:: default


    # Load raw data
    data_path = mne.datasets.ssvep.data_path()
    bids_fname = data_path + '/sub-02/ses-01/eeg/sub-02_ses-01_task-ssvep_eeg.vhdr'

    raw = mne.io.read_raw_brainvision(bids_fname, preload=True, verbose=False)
    raw.info['line_freq'] = 50.

    # Set montage
    montage = mne.channels.make_standard_montage('easycap-M1')
    raw.set_montage(montage, verbose=False)

    # Set common average reference
    raw.set_eeg_reference('average', projection=False, verbose=False)

    # Apply bandpass filter
    raw.filter(l_freq=0.1, h_freq=None, fir_design='firwin', verbose=False)

    # Construct epochs
    event_id = {
        '12hz': 255,
        '15hz': 155
    }
    events, _ = mne.events_from_annotations(raw, verbose=False)
    raw.info["events"] = events
    tmin, tmax = -1., 20.  # in s
    baseline = None
    epochs = mne.Epochs(
        raw, events=events,
        event_id=[event_id['12hz'], event_id['15hz']], tmin=tmin,
        tmax=tmax, baseline=baseline, verbose=False)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Using default location ~/mne_data for ssvep...
    Creating ~/mne_data
    Downloading archive ssvep_example_data.zip to /github/home/mne_data
    Downloading https://files.de-1.osf.io/v1/resources/7ne6y/providers/osfstorage/5f0ed12ce8dcdd00a0ef20b7?version=5&action=download&direct (37.7 MB)
      0%|          | Downloading : 0.00/37.7M [00:00<?,        ?B/s]      0%|          | Downloading : 24.0k/37.7M [00:00<01:03,     618kB/s]      0%|          | Downloading : 40.0k/37.7M [00:00<01:04,     608kB/s]      0%|          | Downloading : 56.0k/37.7M [00:00<01:05,     598kB/s]      0%|          | Downloading : 72.0k/37.7M [00:00<01:17,     511kB/s]      0%|          | Downloading : 88.0k/37.7M [00:00<01:16,     513kB/s]      0%|          | Downloading : 112k/37.7M [00:00<01:15,     518kB/s]       0%|          | Downloading : 128k/37.7M [00:00<01:15,     524kB/s]      0%|          | Downloading : 144k/37.7M [00:00<01:13,     533kB/s]      0%|          | Downloading : 160k/37.7M [00:00<01:13,     537kB/s]      0%|          | Downloading : 176k/37.7M [00:00<01:12,     542kB/s]      0%|          | Downloading : 192k/37.7M [00:00<01:11,     547kB/s]      1%|          | Downloading : 208k/37.7M [00:00<01:10,     555kB/s]      1%|          | Downloading : 224k/37.7M [00:00<01:09,     565kB/s]      1%|          | Downloading : 240k/37.7M [00:00<01:08,     576kB/s]      1%|          | Downloading : 256k/37.7M [00:00<01:06,     588kB/s]      1%|          | Downloading : 288k/37.7M [00:00<01:05,     603kB/s]      1%|          | Downloading : 320k/37.7M [00:00<01:02,     623kB/s]      1%|          | Downloading : 352k/37.7M [00:00<01:00,     644kB/s]      1%|          | Downloading : 384k/37.7M [00:00<00:58,     666kB/s]      1%|1         | Downloading : 416k/37.7M [00:00<00:56,     689kB/s]      1%|1         | Downloading : 448k/37.7M [00:00<00:54,     712kB/s]      1%|1         | Downloading : 512k/37.7M [00:00<00:52,     736kB/s]      1%|1         | Downloading : 576k/37.7M [00:00<00:51,     762kB/s]      2%|1         | Downloading : 640k/37.7M [00:00<00:49,     789kB/s]      2%|1         | Downloading : 736k/37.7M [00:00<00:47,     820kB/s]      2%|2         | Downloading : 800k/37.7M [00:00<00:45,     853kB/s]      2%|2         | Downloading : 864k/37.7M [00:00<00:43,     888kB/s]      3%|2         | Downloading : 992k/37.7M [00:00<00:41,     925kB/s]      3%|2         | Downloading : 1.09M/37.7M [00:00<00:39,     965kB/s]      3%|3         | Downloading : 1.22M/37.7M [00:00<00:37,    1.01MB/s]      4%|3         | Downloading : 1.34M/37.7M [00:00<00:36,    1.05MB/s]      4%|3         | Downloading : 1.47M/37.7M [00:00<00:34,    1.10MB/s]      4%|4         | Downloading : 1.59M/37.7M [00:00<00:33,    1.14MB/s]      5%|4         | Downloading : 1.72M/37.7M [00:00<00:31,    1.20MB/s]      5%|5         | Downloading : 1.97M/37.7M [00:00<00:29,    1.25MB/s]      6%|5         | Downloading : 2.22M/37.7M [00:00<00:28,    1.31MB/s]      7%|6         | Downloading : 2.47M/37.7M [00:00<00:26,    1.37MB/s]      8%|7         | Downloading : 2.84M/37.7M [00:01<00:25,    1.43MB/s]      8%|8         | Downloading : 3.09M/37.7M [00:01<00:24,    1.50MB/s]      9%|8         | Downloading : 3.34M/37.7M [00:01<00:22,    1.57MB/s]     10%|9         | Downloading : 3.59M/37.7M [00:01<00:21,    1.64MB/s]     11%|#         | Downloading : 4.09M/37.7M [00:01<00:20,    1.72MB/s]     12%|#2        | Downloading : 4.59M/37.7M [00:01<00:19,    1.80MB/s]     14%|#3        | Downloading : 5.09M/37.7M [00:01<00:18,    1.89MB/s]     15%|#4        | Downloading : 5.59M/37.7M [00:01<00:16,    1.98MB/s]     16%|#6        | Downloading : 6.09M/37.7M [00:01<00:15,    2.08MB/s]     19%|#8        | Downloading : 7.09M/37.7M [00:01<00:14,    2.18MB/s]     20%|##        | Downloading : 7.59M/37.7M [00:01<00:13,    2.26MB/s]     21%|##1       | Downloading : 8.09M/37.7M [00:01<00:13,    2.34MB/s]     23%|##2       | Downloading : 8.59M/37.7M [00:01<00:12,    2.41MB/s]     24%|##4       | Downloading : 9.09M/37.7M [00:01<00:12,    2.48MB/s]     25%|##5       | Downloading : 9.59M/37.7M [00:01<00:11,    2.51MB/s]     26%|##6       | Downloading : 9.84M/37.7M [00:01<00:11,    2.56MB/s]     27%|##6       | Downloading : 10.1M/37.7M [00:01<00:10,    2.63MB/s]     27%|##7       | Downloading : 10.3M/37.7M [00:01<00:10,    2.70MB/s]     28%|##8       | Downloading : 10.6M/37.7M [00:01<00:10,    2.77MB/s]     29%|##8       | Downloading : 10.8M/37.7M [00:01<00:09,    2.83MB/s]     29%|##9       | Downloading : 11.1M/37.7M [00:02<00:09,    2.92MB/s]     30%|###       | Downloading : 11.3M/37.7M [00:02<00:09,    3.00MB/s]     31%|###       | Downloading : 11.6M/37.7M [00:02<00:08,    3.05MB/s]     31%|###1      | Downloading : 11.8M/37.7M [00:02<00:08,    3.11MB/s]     32%|###2      | Downloading : 12.1M/37.7M [00:02<00:08,    3.20MB/s]     33%|###2      | Downloading : 12.3M/37.7M [00:02<00:08,    3.28MB/s]     33%|###3      | Downloading : 12.6M/37.7M [00:02<00:07,    3.34MB/s]     34%|###4      | Downloading : 12.8M/37.7M [00:02<00:07,    3.39MB/s]     35%|###4      | Downloading : 13.1M/37.7M [00:02<00:07,    3.48MB/s]     35%|###5      | Downloading : 13.3M/37.7M [00:02<00:07,    3.56MB/s]     36%|###6      | Downloading : 13.6M/37.7M [00:02<00:06,    3.61MB/s]     37%|###6      | Downloading : 13.8M/37.7M [00:02<00:06,    3.61MB/s]     37%|###7      | Downloading : 14.1M/37.7M [00:02<00:06,    3.71MB/s]     38%|###8      | Downloading : 14.3M/37.7M [00:02<00:06,    3.75MB/s]     39%|###8      | Downloading : 14.6M/37.7M [00:02<00:06,    3.77MB/s]     39%|###9      | Downloading : 14.8M/37.7M [00:02<00:06,    3.78MB/s]     40%|####      | Downloading : 15.1M/37.7M [00:02<00:06,    3.87MB/s]     41%|####      | Downloading : 15.3M/37.7M [00:02<00:05,    3.92MB/s]     41%|####1     | Downloading : 15.6M/37.7M [00:02<00:05,    3.98MB/s]     42%|####2     | Downloading : 15.8M/37.7M [00:02<00:05,    4.02MB/s]     43%|####2     | Downloading : 16.1M/37.7M [00:03<00:05,    4.10MB/s]     43%|####3     | Downloading : 16.3M/37.7M [00:03<00:05,    4.17MB/s]     44%|####4     | Downloading : 16.6M/37.7M [00:03<00:05,    4.19MB/s]     45%|####4     | Downloading : 16.8M/37.7M [00:03<00:05,    4.21MB/s]     45%|####5     | Downloading : 17.1M/37.7M [00:03<00:05,    4.29MB/s]     46%|####6     | Downloading : 17.3M/37.7M [00:03<00:04,    4.27MB/s]     47%|####6     | Downloading : 17.6M/37.7M [00:03<00:04,    4.24MB/s]     47%|####7     | Downloading : 17.8M/37.7M [00:03<00:04,    4.20MB/s]     48%|####8     | Downloading : 18.1M/37.7M [00:03<00:04,    4.29MB/s]     49%|####8     | Downloading : 18.3M/37.7M [00:03<00:04,    4.36MB/s]     49%|####9     | Downloading : 18.6M/37.7M [00:03<00:04,    4.40MB/s]     50%|#####     | Downloading : 18.8M/37.7M [00:03<00:04,    4.36MB/s]     51%|#####     | Downloading : 19.1M/37.7M [00:03<00:04,    4.44MB/s]     51%|#####1    | Downloading : 19.3M/37.7M [00:03<00:04,    4.51MB/s]     52%|#####2    | Downloading : 19.6M/37.7M [00:03<00:04,    4.53MB/s]     53%|#####2    | Downloading : 19.8M/37.7M [00:03<00:04,    4.55MB/s]     53%|#####3    | Downloading : 20.1M/37.7M [00:03<00:03,    4.64MB/s]     54%|#####4    | Downloading : 20.3M/37.7M [00:03<00:03,    4.71MB/s]     55%|#####4    | Downloading : 20.6M/37.7M [00:03<00:03,    4.74MB/s]     55%|#####5    | Downloading : 20.8M/37.7M [00:03<00:03,    4.75MB/s]     56%|#####6    | Downloading : 21.1M/37.7M [00:04<00:03,    4.83MB/s]     57%|#####6    | Downloading : 21.3M/37.7M [00:04<00:03,    4.91MB/s]     57%|#####7    | Downloading : 21.6M/37.7M [00:04<00:03,    4.92MB/s]     58%|#####8    | Downloading : 21.8M/37.7M [00:04<00:03,    4.91MB/s]     59%|#####8    | Downloading : 22.1M/37.7M [00:04<00:03,    4.97MB/s]     59%|#####9    | Downloading : 22.3M/37.7M [00:04<00:03,    5.01MB/s]     60%|#####9    | Downloading : 22.6M/37.7M [00:04<00:03,    5.05MB/s]     61%|######    | Downloading : 22.8M/37.7M [00:04<00:03,    5.04MB/s]     61%|######1   | Downloading : 23.1M/37.7M [00:04<00:03,    5.07MB/s]     62%|######1   | Downloading : 23.3M/37.7M [00:04<00:02,    5.07MB/s]     63%|######2   | Downloading : 23.6M/37.7M [00:04<00:02,    5.05MB/s]     63%|######3   | Downloading : 23.8M/37.7M [00:04<00:02,    4.99MB/s]     64%|######3   | Downloading : 24.1M/37.7M [00:04<00:02,    5.00MB/s]     65%|######4   | Downloading : 24.3M/37.7M [00:04<00:02,    4.98MB/s]     65%|######5   | Downloading : 24.6M/37.7M [00:04<00:02,    4.99MB/s]     66%|######5   | Downloading : 24.8M/37.7M [00:04<00:02,    4.95MB/s]     67%|######6   | Downloading : 25.1M/37.7M [00:04<00:02,    4.99MB/s]     67%|######7   | Downloading : 25.3M/37.7M [00:04<00:02,    5.09MB/s]     68%|######7   | Downloading : 25.6M/37.7M [00:04<00:02,    5.16MB/s]     69%|######8   | Downloading : 25.8M/37.7M [00:04<00:02,    5.17MB/s]     69%|######9   | Downloading : 26.1M/37.7M [00:04<00:02,    5.23MB/s]     70%|######9   | Downloading : 26.3M/37.7M [00:05<00:02,    5.25MB/s]     71%|#######   | Downloading : 26.6M/37.7M [00:05<00:02,    5.31MB/s]     71%|#######1  | Downloading : 26.8M/37.7M [00:05<00:02,    5.33MB/s]     72%|#######1  | Downloading : 27.1M/37.7M [00:05<00:02,    5.40MB/s]     73%|#######2  | Downloading : 27.3M/37.7M [00:05<00:01,    5.47MB/s]     73%|#######3  | Downloading : 27.6M/37.7M [00:05<00:01,    5.50MB/s]     74%|#######3  | Downloading : 27.8M/37.7M [00:05<00:01,    5.52MB/s]     75%|#######4  | Downloading : 28.1M/37.7M [00:05<00:01,    5.57MB/s]     75%|#######5  | Downloading : 28.3M/37.7M [00:05<00:01,    5.62MB/s]     76%|#######5  | Downloading : 28.6M/37.7M [00:05<00:01,    5.69MB/s]     77%|#######6  | Downloading : 28.8M/37.7M [00:05<00:01,    5.70MB/s]     77%|#######7  | Downloading : 29.1M/37.7M [00:05<00:01,    5.76MB/s]     78%|#######7  | Downloading : 29.3M/37.7M [00:05<00:01,    5.84MB/s]     79%|#######8  | Downloading : 29.6M/37.7M [00:05<00:01,    5.88MB/s]     79%|#######9  | Downloading : 29.8M/37.7M [00:05<00:01,    5.88MB/s]     80%|#######9  | Downloading : 30.1M/37.7M [00:05<00:01,    5.91MB/s]     81%|########  | Downloading : 30.3M/37.7M [00:05<00:01,    5.96MB/s]     81%|########1 | Downloading : 30.6M/37.7M [00:05<00:01,    6.01MB/s]     82%|########1 | Downloading : 30.8M/37.7M [00:05<00:01,    5.99MB/s]     83%|########2 | Downloading : 31.1M/37.7M [00:05<00:01,    6.05MB/s]     83%|########3 | Downloading : 31.3M/37.7M [00:05<00:01,    6.14MB/s]     84%|########3 | Downloading : 31.6M/37.7M [00:05<00:01,    6.17MB/s]     85%|########4 | Downloading : 31.8M/37.7M [00:05<00:00,    6.17MB/s]     85%|########5 | Downloading : 32.1M/37.7M [00:05<00:00,    6.17MB/s]     86%|########5 | Downloading : 32.3M/37.7M [00:05<00:00,    6.25MB/s]     87%|########6 | Downloading : 32.6M/37.7M [00:05<00:00,    6.29MB/s]     87%|########7 | Downloading : 32.8M/37.7M [00:06<00:00,    6.24MB/s]     88%|########7 | Downloading : 33.1M/37.7M [00:06<00:00,    6.27MB/s]     89%|########8 | Downloading : 33.3M/37.7M [00:06<00:00,    6.30MB/s]     89%|########9 | Downloading : 33.6M/37.7M [00:06<00:00,    6.30MB/s]     90%|########9 | Downloading : 33.8M/37.7M [00:06<00:00,    6.20MB/s]     91%|######### | Downloading : 34.1M/37.7M [00:06<00:00,    6.20MB/s]     91%|#########1| Downloading : 34.3M/37.7M [00:06<00:00,    6.29MB/s]     92%|#########1| Downloading : 34.6M/37.7M [00:06<00:00,    6.34MB/s]     93%|#########2| Downloading : 34.8M/37.7M [00:06<00:00,    6.33MB/s]     93%|#########3| Downloading : 35.1M/37.7M [00:06<00:00,    6.35MB/s]     94%|#########3| Downloading : 35.3M/37.7M [00:06<00:00,    6.44MB/s]     95%|#########4| Downloading : 35.6M/37.7M [00:06<00:00,    6.48MB/s]     95%|#########5| Downloading : 35.8M/37.7M [00:06<00:00,    6.47MB/s]     96%|#########5| Downloading : 36.1M/37.7M [00:06<00:00,    6.48MB/s]     97%|#########6| Downloading : 36.3M/37.7M [00:06<00:00,    6.57MB/s]     97%|#########7| Downloading : 36.6M/37.7M [00:06<00:00,    6.60MB/s]     98%|#########7| Downloading : 36.8M/37.7M [00:06<00:00,    6.52MB/s]     99%|#########8| Downloading : 37.1M/37.7M [00:06<00:00,    6.43MB/s]     99%|#########9| Downloading : 37.3M/37.7M [00:06<00:00,    6.52MB/s]    100%|#########9| Downloading : 37.6M/37.7M [00:06<00:00,    6.57MB/s]    100%|##########| Downloading : 37.7M/37.7M [00:06<00:00,    5.77MB/s]    100%|##########| Downloading : 37.7M/37.7M [00:06<00:00,    5.79MB/s]
    Verifying hash af866bbc0f921114ac9d683494fe87d6.
    Decompressing the archive: /github/home/mne_data/ssvep_example_data.zip
    (please be patient, this can take some time)
    Successfully extracted to: ['/github/home/mne_data/ssvep-example-data']
    Attempting to create new mne-python configuration file:
    /github/home/.mne/mne-python.json




.. GENERATED FROM PYTHON SOURCE LINES 92-128

Frequency analysis
------------------
Now we compute the frequency spectrum of the EEG data.
You will already see the peaks at the stimulation frequencies and some of
their harmonics, without any further processing.

The 'classical' PSD plot will be compared to a plot of the SNR spectrum.
SNR will be computed as a ratio of the power in a given frequency bin
to the average power in its neighboring bins.
This procedure has two advantages over using the raw PSD:

* it normalizes the spectrum and accounts for 1/f power decay.

* power modulations which are not very narrow band will disappear.

Calculate power spectral density (PSD)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The frequency spectrum will be computed using Fast Fourier transform (FFT).
This seems to be common practice in the steady-state literature and is
based on the exact knowledge of the stimulus and the assumed response -
especially in terms of it's stability over time.
For a discussion see e.g.
`Bach & Meigen (1999) <https://doi.org/10.1023/A:1002648202420>`_

We will exclude the first second of each trial from the analysis:

* steady-state response often take a while to stabilize, and the
  transient phase in the beginning can distort the signal estimate.

* this section of data is expected to be dominated by responses related to
  the stimulus onset, and we are not interested in this.

In MNE we call plain FFT as a special case of Welch's method, with only a
single Welch window spanning the entire trial and no specific windowing
function (i.e. applying a boxcar window).


.. GENERATED FROM PYTHON SOURCE LINES 128-135

.. code-block:: default


    fmin, fmax = 1., 90.
    spectrum = psd_from_mne_epochs(epochs, tmin=1., tmax=20.,
                                   fmin=fmin, fmax=fmax)
    psds, freqs = spectrum.data, spectrum.frequencies









.. GENERATED FROM PYTHON SOURCE LINES 136-152

Calculate signal to noise ratio (SNR)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SNR - as we define it here - is a measure of relative power:
it's the ratio of power in a given frequency bin - the 'signal' -
to a 'noise' baseline - the average power in the surrounding frequency bins.
This approach was initially proposed by
`Meigen & Bach (1999) <https://doi.org/10.1023/A:1002097208337>`_

Hence, we need to set some parameters for this baseline - how many
neighboring bins should be taken for this computation, and do we want to skip
the direct neighbors (this can make sense if the stimulation frequency is not
super constant, or frequency bands are very narrow).

The function below does what we want.


.. GENERATED FROM PYTHON SOURCE LINES 152-200

.. code-block:: default


    def snr_spectrum(psd, noise_n_neighbor_freqs=1, noise_skip_neighbor_freqs=1):
        """Compute SNR spectrum from PSD spectrum using convolution.
        Parameters
        ----------
        psd : ndarray, shape ([n_trials, n_channels,] n_frequency_bins)
            Data object containing PSD values. Works with arrays as produced by
            MNE's PSD functions or channel/trial subsets.
        noise_n_neighbor_freqs : int
            Number of neighboring frequencies used to compute noise level.
            increment by one to add one frequency bin ON BOTH SIDES
        noise_skip_neighbor_freqs : int
            set this >=1 if you want to exclude the immediately neighboring
            frequency bins in noise level calculation
        Returns
        -------
        snr : ndarray, shape ([n_trials, n_channels,] n_frequency_bins)
            Array containing SNR for all epochs, channels, frequency bins.
            NaN for frequencies on the edges, that do not have enough neighbors on
            one side to calculate SNR.
        """
        # Construct a kernel that calculates the mean of the neighboring
        # frequencies
        averaging_kernel = np.concatenate((
            np.ones(noise_n_neighbor_freqs),
            np.zeros(2 * noise_skip_neighbor_freqs + 1),
            np.ones(noise_n_neighbor_freqs)))
        averaging_kernel /= averaging_kernel.sum()

        # Calculate the mean of the neighboring frequencies by convolving with the
        # averaging kernel.
        mean_noise = np.apply_along_axis(
            lambda psd_: np.convolve(psd_, averaging_kernel, mode='valid'),
            axis=-1, arr=psd
        )

        # The mean is not defined on the edges so we will pad it with nas. The
        # padding needs to be done for the last dimension only so we set it to
        # (0, 0) for the other ones.
        edge_width = noise_n_neighbor_freqs + noise_skip_neighbor_freqs
        pad_width = [(0, 0)] * (mean_noise.ndim - 1) + [(edge_width, edge_width)]
        mean_noise = np.pad(
            mean_noise, pad_width=pad_width, constant_values=np.nan
        )

        return psd / mean_noise









.. GENERATED FROM PYTHON SOURCE LINES 201-223

Now we call the function to compute our SNR spectrum.

As described above, we have to define two parameters.

* how many noise bins do we want?

* do we want to skip the n bins directly next to the target bin?


Tweaking these parameters *can* drastically impact the resulting spectrum,
but mainly if you choose extremes.
E.g. if you'd skip very many neighboring bins, broad band power modulations
(such as the alpha peak) should reappear in the SNR spectrum.
On the other hand, if you skip none you might miss or smear peaks if the
induced power is distributed over two or more frequency bins (e.g. if the
stimulation frequency isn't perfectly constant, or you have very narrow
bins).

Here, we want to compare power at each bin with average power of the
**three neighboring bins** (on each side) and **skip one bin** directly next
to it.


.. GENERATED FROM PYTHON SOURCE LINES 223-228

.. code-block:: default



    snrs = snr_spectrum(psds, noise_n_neighbor_freqs=3,
                        noise_skip_neighbor_freqs=1)








.. GENERATED FROM PYTHON SOURCE LINES 229-235

Plot PSD and SNR spectra
^^^^^^^^^^^^^^^^^^^^^^^^
Now we will plot grand average PSD (in blue) and SNR (in red) ± sd
for every frequency bin.
PSD is plotted on a log scale.


.. GENERATED FROM PYTHON SOURCE LINES 235-262

.. code-block:: default


    fig, axes = plt.subplots(2, 1, sharex='all', sharey='none', figsize=(8, 5))
    freq_range = range(np.where(np.floor(freqs) == 1.)[0][0],
                       np.where(np.ceil(freqs) == fmax - 1)[0][0])

    psds_plot = 10 * np.log10(psds)
    psds_mean = psds_plot.mean(axis=(0, 1))[freq_range]
    psds_std = psds_plot.std(axis=(0, 1))[freq_range]
    axes[0].plot(freqs[freq_range], psds_mean, color='b')
    axes[0].fill_between(
        freqs[freq_range], psds_mean - psds_std, psds_mean + psds_std,
        color='b', alpha=.2)
    axes[0].set(title="PSD spectrum", ylabel='Power Spectral Density [dB]')

    # SNR spectrum
    snr_mean = snrs.mean(axis=(0, 1))[freq_range]
    snr_std = snrs.std(axis=(0, 1))[freq_range]

    axes[1].plot(freqs[freq_range], snr_mean, color='r')
    axes[1].fill_between(
        freqs[freq_range], snr_mean - snr_std, snr_mean + snr_std,
        color='r', alpha=.2)
    axes[1].set(
        title="SNR spectrum", xlabel='Frequency [Hz]',
        ylabel='SNR', ylim=[-2, 30], xlim=[fmin, fmax])
    fig.show()




.. image:: /auto_examples/images/sphx_glr_plot_mne_freqtag_tutorial_001.png
    :alt: PSD spectrum, SNR spectrum
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 263-298

You can see that the peaks at the stimulation frequencies (12 Hz, 15 Hz)
and their harmonics are visible in both plots (just as the line noise at
50 Hz).
Yet, the SNR spectrum shows them more prominently as peaks from a
noisy but more or less constant baseline of SNR = 1.
You can further see that the SNR processing removes any broad-band power
differences (such as the increased power in alpha band around 10 Hz),
and also removes the 1/f decay in the PSD.

Note, that while the SNR plot implies the possibility of values below 0
(mean minus sd) such values do not make sense.
Each SNR value is a ratio of positive PSD values, and the lowest possible PSD
value is 0 (negative Y-axis values in the upper panel only result from
plotting PSD on a log scale).
Hence SNR values must be positive and can minimally go towards 0.

Extract SNR values at the stimulation frequency
-----------------------------------------------

Our processing yielded a large array of many SNR values for each trial x
channel x frequency-bin of the PSD array.

For statistical analysis we obviously need to define specific subsets of this
array. First of all, we are only interested in SNR at the stimulation
frequency, but we also want to restrict the analysis to a spatial ROI.
Lastly, answering your interesting research questions will probably rely on
comparing SNR in different trials.

Therefore we will have to find the indices of trials, channels, etc.
Alternatively, one could subselect the trials already at the epoching step,
using MNE's event information, and process different epoch structures
separately.

Let's only have a look at the trials with 12 Hz stimulation, for now.


.. GENERATED FROM PYTHON SOURCE LINES 298-302

.. code-block:: default


    # define stimulation frequency
    stim_freq = 12.








.. GENERATED FROM PYTHON SOURCE LINES 303-310

Get index for the stimulation frequency (12 Hz)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Ideally, there would be a bin with the stimulation frequency exactly in its
center. However, depending on your Spectral decomposition this is not
always the case. We will find the bin closest to it - this one should contain
our frequency tagged response.


.. GENERATED FROM PYTHON SOURCE LINES 310-323

.. code-block:: default


    # find index of frequency bin closest to stimulation frequency
    i_bin_12hz = np.argmin(abs(freqs - stim_freq))
    # could be updated to support multiple frequencies

    # for later, we will already find the 15 Hz bin and the 1st and 2nd harmonic
    # for both.
    i_bin_24hz = np.argmin(abs(freqs - 24))
    i_bin_36hz = np.argmin(abs(freqs - 36))
    i_bin_15hz = np.argmin(abs(freqs - 15))
    i_bin_30hz = np.argmin(abs(freqs - 30))
    i_bin_45hz = np.argmin(abs(freqs - 45))








.. GENERATED FROM PYTHON SOURCE LINES 324-326

Get indices for the different trial types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 326-330

.. code-block:: default


    i_trial_12hz = np.where(epochs.events[:, 2] == event_id['12hz'])[0]
    i_trial_15hz = np.where(epochs.events[:, 2] == event_id['15hz'])[0]








.. GENERATED FROM PYTHON SOURCE LINES 331-333

Get indices of EEG channels forming the ROI
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 333-342

.. code-block:: default


    # Define different ROIs
    roi_vis = ['POz', 'Oz', 'O1', 'O2', 'PO3', 'PO4', 'PO7',
               'PO8', 'PO9', 'PO10', 'O9', 'O10']  # visual roi

    # Find corresponding indices using mne.pick_types()
    picks_roi_vis = mne.pick_types(epochs.info, eeg=True, stim=False,
                                   exclude='bads', selection=roi_vis)








.. GENERATED FROM PYTHON SOURCE LINES 343-352

Apply the subset, and check the result
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we simply need to apply our selection and yield a result. Therefore,
we typically report grand average SNR over the subselection.

In this tutorial we don't verify the presence of a neural response.
This is commonly done in the ASSR literature where SNR is
often lower. An F-test or Hotelling T² would be
appropriate for this purpose.

.. GENERATED FROM PYTHON SOURCE LINES 352-357

.. code-block:: default


    snrs_target = snrs[i_trial_12hz, :, i_bin_12hz][:, picks_roi_vis]
    print("sub 2, 12 Hz trials, SNR at 12 Hz")
    print(f'average SNR (occipital ROI): {snrs_target.mean()}')





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    sub 2, 12 Hz trials, SNR at 12 Hz
    average SNR (occipital ROI): 41.6936554171862




.. GENERATED FROM PYTHON SOURCE LINES 358-372

Topography of the vSSR
----------------------
But wait...
As described in the intro, we have decided *a priori* to work with average
SNR over a subset of occipital channels - a visual region of interest (ROI)
- because we expect SNR to be higher on these channels than in other
channels.

Let's check out, whether this was a good decision!

Here we will plot average SNR for each channel location as a topoplot.
Then we will do a simple paired T-test to check, whether average SNRs over
the two sets of channels are significantly different.


.. GENERATED FROM PYTHON SOURCE LINES 372-390

.. code-block:: default


    # get average SNR at 12 Hz for ALL channels
    snrs_12hz = snrs[i_trial_12hz, :, i_bin_12hz]
    snrs_12hz_chaverage = snrs_12hz.mean(axis=0)

    # plot SNR topography
    fig, ax = plt.subplots(1)
    mne.viz.plot_topomap(snrs_12hz_chaverage, epochs.info, vmin=1., axes=ax)

    print("sub 2, 12 Hz trials, SNR at 12 Hz")
    print("average SNR (all channels): %f" % snrs_12hz_chaverage.mean())
    print("average SNR (occipital ROI): %f" % snrs_target.mean())

    tstat_roi_vs_scalp = \
        ttest_rel(snrs_target.mean(axis=1), snrs_12hz.mean(axis=1))
    print("12 Hz SNR in occipital ROI is significantly larger than 12 Hz SNR over "
          "all channels: t = %.3f, p = %f" % tstat_roi_vs_scalp)




.. image:: /auto_examples/images/sphx_glr_plot_mne_freqtag_tutorial_002.png
    :alt: plot mne freqtag tutorial
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    sub 2, 12 Hz trials, SNR at 12 Hz
    average SNR (all channels): 16.985902
    average SNR (occipital ROI): 41.693655
    12 Hz SNR in occipital ROI is significantly larger than 12 Hz SNR over all channels: t = 6.950, p = 0.000067




.. GENERATED FROM PYTHON SOURCE LINES 391-427

We can see, that 1) this participant indeed exhibits a cluster of channels
with high SNR in the occipital region and 2) that the average SNR over all
channels is smaller than the average of the visual ROI computed above.
The difference is statistically significant. Great!

Such a topography plot can be a nice tool to explore and play with your data
- e.g. you could try how changing the reference will affect the spatial
distribution of SNR values.

However, we also wanted to show this plot to point at a potential
problem with frequency-tagged (or any other brain imaging) data:
there are many channels and somewhere you will likely find some
statistically significant effect.
It is very easy - even unintended - to end up double-dipping or p-hacking.
So if you want to work with an ROI or individual channels, ideally select
them *a priori* - before collecting or looking at the data - and preregister
this decision so people will believe you.
If you end up selecting an ROI or individual channel for reporting *because
this channel or ROI shows an effect*, e.g. in an explorative analysis, this
is also fine but make it transparently and correct for multiple comparison.

Statistical separation of 12 Hz and 15 Hz vSSR
----------------------------------------------
After this little detour into open science, let's move on and
do the analyses we actually wanted to do:

We will show that we can easily detect and discriminate the brains responses
in the trials with different stimulation frequencies.

In the frequency and SNR spectrum plot above, we had all trials mixed up.
Now we will extract 12 and 15 Hz SNR in both types of trials individually,
and compare the values with a simple t-test.
We will also extract SNR of the 1st and 2nd harmonic for both stimulation
frequencies. These are often reported as well and can show interesting
interactions.


.. GENERATED FROM PYTHON SOURCE LINES 427-468

.. code-block:: default


    snrs_roi = snrs[:, picks_roi_vis, :].mean(axis=1)

    freq_plot = [12, 15, 24, 30, 36, 45]
    color_plot = [
        'darkblue', 'darkgreen', 'mediumblue', 'green', 'blue', 'seagreen'
    ]
    xpos_plot = [-5. / 12, -3. / 12, -1. / 12, 1. / 12, 3. / 12, 5. / 12]
    fig, ax = plt.subplots()
    labels = ['12 Hz trials', '15 Hz trials']
    x = np.arange(len(labels))  # the label locations
    width = 0.6  # the width of the bars
    res = dict()

    # loop to plot SNRs at stimulation frequencies and harmonics
    for i, f in enumerate(freq_plot):
        # extract snrs
        stim_12hz_tmp = \
            snrs_roi[i_trial_12hz, np.argmin(abs(freqs - f))]
        stim_15hz_tmp = \
            snrs_roi[i_trial_15hz, np.argmin(abs(freqs - f))]
        SNR_tmp = [stim_12hz_tmp.mean(), stim_15hz_tmp.mean()]
        # plot (with std)
        ax.bar(
            x + width * xpos_plot[i], SNR_tmp, width / len(freq_plot),
            yerr=np.std(SNR_tmp),
            label='%i Hz SNR' % f, color=color_plot[i])
        # store results for statistical comparison
        res['stim_12hz_snrs_%ihz' % f] = stim_12hz_tmp
        res['stim_15hz_snrs_%ihz' % f] = stim_15hz_tmp

    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_ylabel('SNR')
    ax.set_title('Average SNR at target frequencies')
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend(['%i Hz' % f for f in freq_plot], title='SNR at:')
    ax.set_ylim([0, 70])
    ax.axhline(1, ls='--', c='r')
    fig.show()




.. image:: /auto_examples/images/sphx_glr_plot_mne_freqtag_tutorial_003.png
    :alt: Average SNR at target frequencies
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 469-472

As you can easily see there are striking differences between the trials.
Let's verify this using a series of two-tailed paired T-Tests.


.. GENERATED FROM PYTHON SOURCE LINES 472-506

.. code-block:: default


    # Compare 12 Hz and 15 Hz SNR in trials after averaging over channels

    tstat_12hz_trial_stim = \
        ttest_rel(res['stim_12hz_snrs_12hz'], res['stim_12hz_snrs_15hz'])
    print("12 Hz Trials: 12 Hz SNR is significantly higher than 15 Hz SNR"
          ": t = %.3f, p = %f" % tstat_12hz_trial_stim)

    tstat_12hz_trial_1st_harmonic = \
        ttest_rel(res['stim_12hz_snrs_24hz'], res['stim_12hz_snrs_30hz'])
    print("12 Hz Trials: 24 Hz SNR is significantly higher than 30 Hz SNR"
          ": t = %.3f, p = %f" % tstat_12hz_trial_1st_harmonic)

    tstat_12hz_trial_2nd_harmonic = \
        ttest_rel(res['stim_12hz_snrs_36hz'], res['stim_12hz_snrs_45hz'])
    print("12 Hz Trials: 36 Hz SNR is significantly higher than 45 Hz SNR"
          ": t = %.3f, p = %f" % tstat_12hz_trial_2nd_harmonic)

    print()
    tstat_15hz_trial_stim = \
        ttest_rel(res['stim_15hz_snrs_12hz'], res['stim_15hz_snrs_15hz'])
    print("15 Hz trials: 12 Hz SNR is significantly lower than 15 Hz SNR"
          ": t = %.3f, p = %f" % tstat_15hz_trial_stim)

    tstat_15hz_trial_1st_harmonic = \
        ttest_rel(res['stim_15hz_snrs_24hz'], res['stim_15hz_snrs_30hz'])
    print("15 Hz trials: 24 Hz SNR is significantly lower than 30 Hz SNR"
          ": t = %.3f, p = %f" % tstat_15hz_trial_1st_harmonic)

    tstat_15hz_trial_2nd_harmonic = \
        ttest_rel(res['stim_15hz_snrs_36hz'], res['stim_15hz_snrs_45hz'])
    print("15 Hz trials: 36 Hz SNR is significantly lower than 45 Hz SNR"
          ": t = %.3f, p = %f" % tstat_15hz_trial_2nd_harmonic)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    12 Hz Trials: 12 Hz SNR is significantly higher than 15 Hz SNR: t = 7.510, p = 0.000037
    12 Hz Trials: 24 Hz SNR is significantly higher than 30 Hz SNR: t = 8.489, p = 0.000014
    12 Hz Trials: 36 Hz SNR is significantly higher than 45 Hz SNR: t = 14.899, p = 0.000000

    15 Hz trials: 12 Hz SNR is significantly lower than 15 Hz SNR: t = -5.692, p = 0.000297
    15 Hz trials: 24 Hz SNR is significantly lower than 30 Hz SNR: t = -7.916, p = 0.000024
    15 Hz trials: 36 Hz SNR is significantly lower than 45 Hz SNR: t = -3.519, p = 0.006525




.. GENERATED FROM PYTHON SOURCE LINES 507-535

Debriefing
----------
So that's it, we hope you enjoyed our little tour through this example
dataset.

As you could see, frequency-tagging is a very powerful tool that can yield
very high signal to noise ratios and effect sizes that enable you to detect
brain responses even within a single participant and single trials of only
a few seconds duration.

Bonus exercises
---------------
For the overly motivated amongst you, let's see what else we can show with
these data.

Using the PSD function as implemented in MNE makes it very easy to change
the amount of data that is actually used in the spectrum
estimation.

Here we employ this to show you some features of frequency
tagging data that you might or might not have already intuitively expected:

Effect of trial duration on SNR
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
First we will simulate shorter trials by taking only the first x s of our 20s
trials (2, 4, 6, 8, ..., 20 s), and compute the SNR using a FFT window
that covers the entire epoch:


.. GENERATED FROM PYTHON SOURCE LINES 535-581

.. code-block:: default


    stim_bandwidth = .5
    sfreq = epochs.info['sfreq']

    # shorten data and welch window
    window_lengths = [i for i in range(2, 21, 2)]
    window_snrs = [[]] * len(window_lengths)
    for i_win, win in enumerate(window_lengths):
        # compute spectrogram
        windowed_psd, windowed_freqs = mne.time_frequency.psd_welch(
            epochs[str(event_id['12hz'])],
            n_fft=int(sfreq * win),
            n_overlap=0, n_per_seg=None,
            tmin=0, tmax=win,
            window='boxcar',
            fmin=fmin, fmax=fmax, verbose=False)
        # define a bandwidth of 1 Hz around stimfreq for SNR computation
        bin_width = windowed_freqs[1] - windowed_freqs[0]
        skip_neighbor_freqs = \
            round((stim_bandwidth / 2) / bin_width - bin_width / 2. - .5) if (
                bin_width < stim_bandwidth) else 0
        n_neighbor_freqs = \
            int((sum((windowed_freqs <= 13) & (windowed_freqs >= 11)
                     ) - 1 - 2 * skip_neighbor_freqs) / 2)
        # compute snr
        windowed_snrs = \
            snr_spectrum(
                windowed_psd,
                noise_n_neighbor_freqs=n_neighbor_freqs if (
                    n_neighbor_freqs > 0
                ) else 1,
                noise_skip_neighbor_freqs=skip_neighbor_freqs)
        window_snrs[i_win] = \
            windowed_snrs[
            :, picks_roi_vis,
            np.argmin(
                abs(windowed_freqs - 12.))].mean(axis=1)

    fig, ax = plt.subplots(1)
    ax.boxplot(window_snrs, labels=window_lengths, vert=True)
    ax.set(title='Effect of trial duration on 12 Hz SNR',
           ylabel='Average SNR', xlabel='Trial duration [s]')
    ax.axhline(1, ls='--', c='r')
    fig.show()





.. image:: /auto_examples/images/sphx_glr_plot_mne_freqtag_tutorial_004.png
    :alt: Effect of trial duration on 12 Hz SNR
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 582-608

You can see that the signal estimate / our SNR measure increases with the
trial duration.

This should be easy to understand: in longer recordings there is simply
more signal (one second of additional stimulation adds, in our case, 12
cycles of signal) while the noise is (hopefully) stochastic and not locked
to the stimulation frequency.
In other words: with more data the signal term grows faster than the noise
term.

We can further see that the very short trials with FFT windows < 2-3s are not
great - here we've either hit the noise floor and/or the transient response
at the trial onset covers too much of the trial.

Again, this tutorial doesn't statistically test for the presence of a neural
response, but an F-test or Hotelling T² would be appropriate for this
purpose.

Time resolved SNR
^^^^^^^^^^^^^^^^^
..and finally we can trick MNE's PSD implementation to make it a
sliding window analysis and come up with a time resolved SNR measure.
This will reveal whether a participant blinked or scratched their head..

Each of the ten trials is coded with a different color in the plot below.


.. GENERATED FROM PYTHON SOURCE LINES 608-651

.. code-block:: default


    # 3s sliding window
    window_length = 4
    window_starts = [i for i in range(20 - window_length)]
    window_snrs = [[]] * len(window_starts)

    for i_win, win in enumerate(window_starts):
        # compute spectrogram
        windowed_psd, windowed_freqs = mne.time_frequency.psd_welch(
            epochs[str(event_id['12hz'])],
            n_fft=int(sfreq * window_length) - 1,
            n_overlap=0, n_per_seg=None,
            window='boxcar',
            tmin=win, tmax=win + window_length,
            fmin=fmin, fmax=fmax,
            verbose=False)
        # define a bandwidth of 1 Hz around stimfreq for SNR computation
        bin_width = windowed_freqs[1] - windowed_freqs[0]
        skip_neighbor_freqs = \
            round((stim_bandwidth / 2) / bin_width - bin_width / 2. - .5) if (
                bin_width < stim_bandwidth) else 0
        n_neighbor_freqs = \
            int((sum((windowed_freqs <= 13) & (windowed_freqs >= 11)
                     ) - 1 - 2 * skip_neighbor_freqs) / 2)
        # compute snr
        windowed_snrs = snr_spectrum(
            windowed_psd,
            noise_n_neighbor_freqs=n_neighbor_freqs if (
                n_neighbor_freqs > 0) else 1,
            noise_skip_neighbor_freqs=skip_neighbor_freqs)
        window_snrs[i_win] = \
            windowed_snrs[:, picks_roi_vis, np.argmin(
                abs(windowed_freqs - 12.))].mean(axis=1)

    fig, ax = plt.subplots(1)
    colors = plt.get_cmap('Greys')(np.linspace(0, 1, 10))
    for i in range(10):
        ax.plot(window_starts, np.array(window_snrs)[:, i], color=colors[i])
    ax.set(title='Time resolved 12 Hz SNR - %is sliding window' % window_length,
           ylabel='Average SNR', xlabel='t0 of analysis window [s]')
    ax.axhline(1, ls='--', c='r')
    ax.legend(['individual trials in greyscale'])
    fig.show()



.. image:: /auto_examples/images/sphx_glr_plot_mne_freqtag_tutorial_005.png
    :alt: Time resolved 12 Hz SNR - 4s sliding window
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 652-658

Well.. turns out this was a bit too optimistic ;)

But seriously: this was a nice idea, but we've reached the limit of
what's possible with this single-subject example dataset.
However, there might be data, applications, or research questions
where such an analysis makes sense.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  20.189 seconds)


.. _sphx_glr_download_auto_examples_plot_mne_freqtag_tutorial.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_mne_freqtag_tutorial.py <plot_mne_freqtag_tutorial.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_mne_freqtag_tutorial.ipynb <plot_mne_freqtag_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
